El objetivo de esta tarea \tnum es comparar diferentes técnicas para resolver un problema específico, evaluando tanto el \textbf{tiempo de ejecución} como el \textbf{uso de memoria}. 

En particular, los estudiantes deberán implementar tres enfoques distintos: un \textbf{algoritmo de fuerza bruta}, dos \textbf{algoritmos greedy} (subóptimos o no necesariamente correctos) y un \textbf{algoritmo de programación dinámica}. La idea es analizar y comparar el rendimiento de cada técnica, y además, en el caso de los algoritmos greedy, evaluar \textbf{qué tan correctas o cercanas a la óptima son las soluciones obtenidas}.

\subsection{Problema}

En \textbf{CppCorp}, una empresa de desarrollo de software fundada en 2001, se busca optimizar la productividad de los desarrolladores. A lo largo de los años, la empresa ha crecido y cuenta con un equipo diverso de programadores con distintos lenguajes favoritos y niveles de experiencia. En el año 2025, Carlos fue nombrado jefe de la empresa y se propuso mejorar la eficiencia y productividad de todos los equipos de desarrollo.

Los empleados están organizados en fila según el orden de ingreso a la empresa, es decir, el empleado $i$ fue el $i$-ésimo en entrar. Cada desarrollador $i$ tiene un \textbf{lenguaje de programación favorito} $C_i$ y si programa en su lenguaje favorito su productividad es $A_i$, mientras que si programa en otro lenguaje su productividad es $B_i$.

Carlos desea formar equipos que maximicen la \textbf{productividad total de la empresa}, definida como la suma de las productividades de todos los equipos. Cada desarrollador \textbf{pertenece exactamente a un equipo}, y no hay empleados fuera de los equipos. Para ello, los equipos se forman como \textbf{segmentos contiguos no vacíos} de la fila de empleados.

La productividad individual de un empleado $i$ dado que programa con el lenguaje $L$ se define como

\[
p_i(L) =
\begin{cases}
A_i & \text{si } C_i = L \\
B_i & \text{si } C_i \neq L
\end{cases}
\]

La productividad de un equipo se obtiene sumando las productividades individuales de todos los miembros del equipo usando el lenguaje que más miembros prefieren, y en caso de empate se toma la opción que genere la menor productividad posible. Formalmente, para un segmento $[l,r]$, la productividad del equipo se define como:
\[
\text{productividad\_equipo}(l,r) = \min_{L \in \arg\max_\ell |\{ i \in [l,r] : C_i = \ell \}|} \sum_{i=l}^{r} p_i(L)
\]

Aquí, $\arg\max_x f(x)$ representa \textbf{el conjunto de valores $x$ que maximizan $f(x)$}. En nuestra fórmula, $|\{ i \in [l,r] : C_i = \ell \}|$ representa la cantidad de miembros del segmento cuyo lenguaje favorito es $\ell$, y por lo tanto
\[
\arg\max_\ell |\{ i \in [l,r] : C_i = \ell \}|
\]
es el \textbf{conjunto de lenguajes más frecuentes} en el segmento.

La \textbf{productividad total de la empresa} se obtiene sumando las productividades de todos los segmentos que forman los equipos:
\[
\text{ProdTotal} = \sum_{\text{segmentos } [l,r]} \text{productividad\_equipo}(l,r)
\]

Cada segmento $[l,r]$ contribuye con su propia productividad según las reglas descritas, y el objetivo es encontrar la \textbf{partición óptima} de la fila que maximice $\text{ProdTotal}$, asegurando que todos los desarrolladores estén incluidos en algún equipo.
